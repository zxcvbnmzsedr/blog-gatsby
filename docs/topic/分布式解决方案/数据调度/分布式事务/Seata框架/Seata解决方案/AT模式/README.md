---
title: AT模式
date: 2022-04-26 15:55
permalink: /topic/%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/Seata%E6%A1%86%E6%9E%B6/Seata%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/AT%E6%A8%A1%E5%BC%8F
topic: 
  - topic
tags: null
categories: 
  - topic
  - 分布式解决方案
  - 数据调度
  - 分布式事务
  - Seata框架
  - Seata解决方案
  - AT模式
---
Seata AT模式是最早⽀持的模式。AT模式是指Automatic (Branch) Transaction Mode⾃动化分⽀事务。

　　Seata AT 模式是增强型2pc模式，或者说是增强型的XA模型。

　　总体来说，AT 模式，是 2pc两阶段提交协议的演变，不同的地⽅，SeataAT 模式不会⼀直锁表。

# 使用前提

* 基于支持本地 ACID 事务的关系型数据库
* Java 应用，通过 JDBC 访问数据库

# 整体机制

　　Seata AT模型图

　　两阶段提交协议的演变：

* ⼀阶段：业务数据和回滚⽇志记录在同⼀个本地事务中提交，释放本地锁和连接资源。

* ⼆阶段：

  * 提交异步化，⾮常快速地完成
  * 或回滚通过⼀阶段的回滚⽇志进⾏反向补偿

　　完整的AT在Seata所制定的事务模式下的模型图：

　　![20201009172509465](https://image.ztianzeng.com/uPic/20201009172509465.png)

# 数据隔离性

## 写隔离

* 一阶段本地事务提交前，需要确保先拿到 **全局锁** 。
* 拿不到 **全局锁** ，不能提交本地事务。
* 拿 **全局锁** 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。

　　以一个示例来说明：

　　两个全局事务 tx1 和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。

　　tx1 先开始，开启本地事务，拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，先拿到该记录的 **全局锁** ，本地提交释放本地锁。 tx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，尝试拿该记录的 **全局锁** ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待 **全局锁** 。

　　‍

　　![seata_at-1](https://image.ztianzeng.com/uPic/seata_at-1.png)

　　tx1 二阶段全局提交，释放 **全局锁** 。tx2 拿到 **全局锁** 提交本地事务。

　　![52J1Ew](https://image.ztianzeng.com/uPic/52J1Ew.jpg)

　　如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。

　　此时，如果 tx2 仍在等待该数据的  **全局锁** ，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 **全局锁** 等锁超时，放弃 **全局锁** 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。

　　因为整个过程 **全局锁** 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 **脏写** 的问题。

## 读隔离

　　在数据库本地事务隔离级别 **读已提交（Read Committed）** 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 **读未提交（Read Uncommitted）** 。

　　如果应用在特定场景下，必需要求全局的 **读已提交** ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。

　　![EmlTOi](https://image.ztianzeng.com/uPic/EmlTOi.jpg)

　　SELECT FOR UPDATE 语句的执行会申请 **全局锁** ，如果 **全局锁** 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 **全局锁** 拿到，即读取的相关数据是 **已提交** 的，才返回。

　　出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。

　　‍
